<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org" />
  <link rel="http://www.w3.org/StyleSheets/Core/Modernist" type=
  "text/css" />

  <title>TTS Servers - Emacspeak User's Manual --2nd
  Edition.</title>
  <meta http-equiv="Content-Type" content="text/html" />
  <meta name="description" content=
  "Emacspeak User's Manual --2nd Edition." />
  <meta name="generator" content="makeinfo 4.13" />
  <link title="Top" rel="start" href="index.html#Top" />
  <link rel="prev" href=
  "Emacspeak-Customizations.html#Emacspeak-Customizations" title=
  "Emacspeak Customizations" />
  <link rel="next" href="Acknowledgments.html#Acknowledgments"
  title="Acknowledgments" />
  <link href="http://www.gnu.org/software/texinfo/" rel=
  "generator-home" title="Texinfo Homepage" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <style type="text/css">
/*<![CDATA[*/
  <!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
  -->
  /*]]>*/
  </style>
</head>

<body>
  <table summary="logo">
    <tr>
      <td><a href="http://emacspeak.sf.net"><img width="150"
      height="216" src="emacspeak.jpg" alt=
      "EMACSPEAK --Complete Audio Desktop" /></a></td>
    </tr>
  </table>

  <div class="node">
    <a name="TTS-Servers" id="TTS-Servers"></a>

    <p>Next:&nbsp;<a rel="next" accesskey="n" href=
    "Acknowledgments.html#Acknowledgments">Acknowledgments</a>,
    Previous:&nbsp;<a rel="previous" accesskey="p" href=
    "Emacspeak-Customizations.html#Emacspeak-Customizations">Emacspeak
    Customizations</a>, Up:&nbsp;<a rel="up" accesskey="u" href=
    "index.html#Top">Top</a></p>
    <hr />
  </div>

  <h2 class="chapter">13 Emacspeak TTS Servers</h2>

  <p>Emacspeak produces spoken output by communicating with one of
  many speech servers. This section documents the communication
  protocol between the client application i.e. Emacspeak, and the
  TTS server. This section is primarily intended for developers
  wishing to:</p>

  <ul>
    <li>Create new speech servers that comply with this
    communication protocol</li>

    <li>Developers of other client applications who wish to use the
    various Emacspeak speech servers.</li>
  </ul>

  <h3 class="section">13.1 High-level Overview</h3>

  <p>The TTS server reads commands from standard input, and script
  <em>speech-server</em> can be used to cause a TTS server to
  communicate via a TCP socket. Speech server commands are used by
  the client application to make specific requests of the server;
  the server listens for these requests in a non-blocking read loop
  and executes requests as they become available. Requests can be
  classified as follows:</p>

  <ul>
    <li>Commands that send text to be spoken.</li>

    <li>Commands that set <em>state</em> of the TTS server.</li>
  </ul>

  <p>All commands are of the form</p>
  <pre class="example">
             commandWord {arguments}
</pre>

  <p>The braces are optional if the command argument contains no
  white space. The speech server maintains a <em>current state</em>
  that determines various characteristics of spoken output such as
  speech rate, punctuations mode etc. (see set of commands that
  manipulate speech state for complete list). The client
  application <em>queues</em> The text and non-speech audio output
  to be produced before asking the server to <em>dispatch</em> the
  set of queued requests, i.e. start producing output.</p>

  <p>Once the server has been asked to produce output, it removes
  items from the front of the queue, sends the requisite commands
  to the underlying TTS engine, and waits for the engine to
  acknowledge that the request has been completely processed. This
  is a non-blocking operation, i.e., if the client application
  generates additional requests, these are processed
  <em>immediately</em>.</p>

  <p>The above design allows the Emacspeak TTS server to be
  <em>highly</em> responsive; Cleint applications can queue large
  amounts of text (typically queued a clause at a time to achieve
  the best prosody), ask the TTS server to start speaking, and
  interrupt the spoken output at any time.</p>

  <h4 class="subsection">13.1.1 Commands That Queue Output.</h4>

  <p>This section documents commands that either produce spoken
  output, or queue output to be produced on demand. Commands that
  place the request on the queue are clearly marked.</p>
  <pre class="example">
             version
</pre>

  <p>Speaks the <em>version</em> of the TTS engine. Produces output
  immediately.</p>
  <pre class="example">
             tts_say text
</pre>

  <p>Speaks the specified <em>text</em> immediately. The text is
  not pre-processed in any way, contrast this with the primary way
  of speaking text which is to queue text before asking the server
  to process the queue.</p>
  <pre class="example">
             l c
</pre>

  <p>Speak <em>c</em> a single character, as a letter. The
  character is spoken immediately. This command uses the TTS
  engine's capability to speak a single character with the ability
  to flush speech <em>immediately</em>. Client applications wishing
  to produce character-at-a-time output, e.g., when providing
  character echo during keyboard input should use this command.</p>
  <pre class="example">
             d
</pre>

  <p>This command is used to <em>dispatch</em> all queued requests.
  It was renamed to a single character command (like many of the
  commonly used TTS server commands) to work more effectively over
  slow (9600) dialup lines. The effect of calling this command is
  for the TTS server to start processing items that have been
  queued via earlier requests.</p>
  <pre class="example">
             tts_pause
</pre>

  <p>This pauses speech <em>immediately</em>. It does not affect
  queued requests; when command <em>tts_resume</em> is called, the
  output resumes at the point where it was paused. Not all TTS
  engines provide this capability.</p>
  <pre class="example">
             tts_resume
</pre>

  <p>Resume spoken output if it has been paused earlier.</p>
  <pre class="example">
             s
</pre>

  <p>Stop speech <em>immediately</em>. Spoken output is
  interrupted, and all pending requests are flushed from the
  queue.</p>
  <pre class="example">
             q text
</pre>

  <p>Queues text to be spoken. No spoken output is produced until a
  <em>dispatch</em> request is received via execution of command
  <em>d</em>.</p>
  <pre class="example">
             c codes
</pre>

  <p>Queues synthesis codes to be sent to the TTS engine. Codes are
  sent to the engine with no further transformation or processing.
  The codes are inserted into the output queue and will be
  dispatched to the TTS engine at the appropriate point in the
  output stream.</p>
  <pre class="example">
             a filename
</pre>

  <p>Cues the audio file identified by filename for playing.</p>
  <pre class="example">
             t freq length
</pre>

  <p>Queues a tone to be played at the specified frequency and
  having the specified length. Frequency is specified in hertz and
  length is specified in milliseconds.</p>
  <pre class="example">
             sh duration
</pre>

  <p>Queues the specified duration of silence. Silence is specified
  in milliseconds.</p>

  <h4 class="subsection">13.1.2 Commands That Set State</h4>
  <pre class="example">
             tts_reset
</pre>

  <p>Reset TTS engine to default settings.</p>
  <pre class="example">
             tts_set_punctuations mode
</pre>

  <p>Sets TTS engine to the specified punctuation mode. Typically,
  TTS servers provide at least three modes:</p>

  <ul>
    <li>None: Do not speak punctuation characters.</li>

    <li>some: Speak some punctuation characters. Used for English
    prose.</li>

    <li>all: Speak out <em>all</em> punctuation characters; useful
    in programming modes.</li>
  </ul>
  <pre class="example">
             tts_set_speech_rate rate
</pre>

  <p>Sets speech rate. The interpretation of this value is
  typically engine specific.</p>
  <pre class="example">
             tts_set_character_scale factor
</pre>

  <p>Scale factor applied to speech rate when speaking individual
  characters.Thus, setting speech rate to 500 and character scale
  to 1.2 will cause command <em>l</em> to use a speech rate of
  <em>500 * 1.2 = 600</em>.</p>
  <pre class="example">
             tts_split_caps flag
</pre>

  <p>Set state of <em>split caps</em> processing. Turn this on to
  speak mixed-case (AKA Camel Case) identifiers.</p>
  <pre class="example">
             tts_capitalize flag
</pre>

  <p>Indicate capitalization via a beep tone or voice pitch.</p>
  <pre class="example">
             tts_allcaps_beep flag
</pre>

  <p>Setting this flag produces a high-pitched beep when speaking
  words that are in all-caps, e.g. abbreviations. 
  <!-- $Id: acknowledge.texi 8272 2013-03-29 15:39:21Z tv.raman.tv $ --></p>
</body>
</html>
